
import subprocess
import shlex
import os.path
import re
import platform
import datetime

VER_MAJOR = 0
VER_MINOR = 1
VER_STRING = str(VER_MAJOR) + "." + str(VER_MINOR)

CONF_FILE_HDR = \
"#%s\n\n\
# Configuration file for DNSMasq.\n\
# This file was auto-generated by Py-DNSMasq V%s.\n\n"


class DNSMasq():
	@property
	def leases(self):
		array = []
		with open(self.lease_file,"r") as fp:
			for line in fp.readlines():
				exp,mac,ip,host,cid = line.strip().split(" ")
				if cid == "*":
					cid = None
				array.append({ 	"expiry-time" : datetime.datetime.fromtimestamp(int(exp)), 
								"mac" : mac,
								"ip" : ip,
								"host" : host,
								"client-id" : cid })
		return array

	@staticmethod
	def runcmd(cmd):
		if platform.system() == "Linux":
			print("Running '%s'" % cmd)
			proc = subprocess.Popen(shlex.split(cmd))
			o,e = proc.communicate()
		else:
			print("Simulating '%s'" % cmd)

		# TODO: Handle errors and exceptions from subprocess.

	@classmethod
	def start(cls):
		cls.runcmd("service dnsmasq start")

	@classmethod
	def stop(cls):
		cls.runcmd("service dnsmasq stop")

	@classmethod
	def restart(cls):
		cls.runcmd("service dnsmasq restart")

	def __getitem__(self,key):
		return self.config[key]

	def __init__(self,root="/etc/dnsmasq.conf",leases="/var/lib/misc/dnsmasq.leases"):
		self.config = DNSMasq_conf(root)
		self.lease_file = leases

	def toip(self,host=None,mac=None):
		if not host == None:
			for lease in self.leases:
				if lease["host"] == host:
					return lease["ip"]
			return None
		elif not mac == None:
			for lease in self.leases:
				if lease["mac"] == mac:
					return lease["ip"]
			return None
		else:
			raise TypeError("getip() missing 1 required argument: 'host'|'mac'")

	def tohost(self,ip=None,mac=None):
		if not ip == None:
			for lease in self.leases:
				if lease["ip"] == ip:
					return lease["host"]
			return None
		elif not mac == None:
			for lease in self.leases:
				if lease["mac"] == mac:
					return lease["host"]
			return None
		else:
			raise TypeError("getip() missing 1 required argument: 'ip'|'mac'")

	def tomac(self,ip=None,host=None):
		if not ip == None:
			for lease in self.leases:
				if lease["ip"] == ip:
					return lease["mac"]
			return None
		elif not host == None:
			for lease in self.leases:
				if lease["host"] == host:
					return lease["mac"]
			return None
		else:
			raise TypeError("getip() missing 1 required argument: 'ip'|'host'")

	def getexpiry(self,ip=None,host=None,mac=None):
		if not ip == None:
			for lease in self.leases:
				if lease["ip"] == ip:
					return lease["expiry-time"]
		elif not mac == None:
			for lease in self.leases:
				if lease["mac"] == mac:
					return lease["expiry-time"]
		elif not host == None:
			for lease in self.leases:
				if lease["host"] == host:
					return lease["expiry-time"]
		else:
			raise TypeError("getexpiry() missing 1 required argument: 'ip'|'host'|'mac'")


class DNSMasq_conf():
	@property
	def paths(self):
		return [fl.path for fl in self.file_list]
	
	def __getitem__(self,key):
		array = []
		for fl in self.file_list:
			for val in fl[key]:
				array.append(val)
		return array
	
	def __init__(self,root="/etc/dnsmasq.conf"):
		self.root = root
		self.file_list = []

		self.parse()

	def parse(self,path=None):
		if path == None:
			path = self.root

		fl = DNSMasq_file(path)
		self.file_list.append(fl)
		for path in fl.links:
			self.parse(path)

	def addfile(self,path):
		self.parse(path)
		self.file_list[0].add("conf-file",[path])

	def write(self):
		for fl in self.file_list:
			fl.write()

	def writeupdates(self):
		for fl in self.file_list:
			if fl.updated == True:
				fl.write()


class DNSMasq_file():
	@property
	def switches(self):
		array = []

		for line in self.lines:
			if len(line) == 1:
				array.append(line[0])
		
		return array
	
	@property
	def links(self):
		try:
			return [f[0] for f in self["conf-file"]]
		except ValueError:
			return []

	def __getitem__(self,key):
		array = []

		for line in self.lines:
			if line[0] == key:
				try:
					array.append(line[1].split(','))
				except IndexError:
					return True

		if not array == []:
			return array
		else:
			#return None
			raise ValueError

	def __init__(self,path):
		self.path = os.path.abspath(path)
		self.lines = []
		self.updated = False

		self.parse()

	def parse(self):
		self.updated = 0
		
		with open(self.path,"r") as fp:
			for line in fp.readlines():
				line = re.sub("#.*","",line).strip()
				if len(line) == 0:
					continue

				self.lines.append(line.split('='))

	def add(self,option,value=None):
		self.updated = True
		
		if value == None:
			self.lines.append(option)
		else:
			self.lines.append([option, ",".join(value)])

	def pop(self,option,idx):
		match = ",".join(self[option][idx])
		for idx,element in enumerate(self.lines):
			if len(element) > 1:
				if element[1] == match:
					print(f'Line match with { element[1] }')
					self.lines.pop(idx)
					break
			else:
				if element[0] == match:
					print(f'Switch match with { element[0] }')
					self.lines.pop(idx)
					break

	def write(self,path=None):
		if path == None:
			path = self.path + ".new"

		with open(path,"w") as fp:
			fp.write(CONF_FILE_HDR % (path,VER_STRING))
			
			for line in self.lines:
				fp.write("=".join(line) + "\n")
		
		self.updated = False